#!/usr/bin/python
#
# bbab2csv - BlackBerry Address Book to CSV
# by Brandon Mintern, bmintern@gmail.com
# Copyright 2011
# Licensed under the GPLv2
# Hosted on github
 
usage = """
Usage: This program is designed to process the result of a backup produced by
the barrybackup command line program. The result of such a backup is a tarball
at ~/.barry/backup/<PIN>/<PIN>-<YYYYMMDD>-<HHMSS>.tar.gz. Inside that tarball
is a directory named "Address Book" which contains a binary file for each
contact.

To run it, execute
  bbab2csv TARBALL
where TARBALL is the file generated by barrybackup. The resulting CSV will
be printed to STDOUT, and unrecognized data will be printed to STDERR.
"""

# The layout of each BlackBerry contact file seems to be:
# 1. 2-byte little-endian field length l
# 2. field type byte
# 3. l-byte field
# 4. (1-3) repeated or 0x00
#
# The following list of tuples indicates the field types (see #2 above) we
# know about. This should probably be split out into a separate file with a
# simple format and then imported here. The order is the same as the order in
# which the columns will be printed out.
#
# After running the program, any unknown fields will be reported to standard
# error. That information can be used to update this program to work better in
# the future.

name = "Name" # This field is directly used in the code for sorting
fields = [ (0x20, name)
         , (0x56, "Nickname")
         , (0x21, "Organization")
         , (0x07, "Home Phone")
         , (0x08, "Mobile Phone")
         , (0x06, "Work Phone")
         , (0x11, "Home Phone 2")
         , (0x12, "Mobile Phone 2")
         , (0x0a, "BB PIN")
         , (0x3d, "Home Address")
         , (0x3e, "Home Address 2")
         , (0x45, "Home City")
         , (0x46, "Home State")
         , (0x47, "Home ZIP")
         , (0x40, "Home Directions")
         , (0x23, "Work Address")
         , (0x24, "Work Address 2")
         , (0x26, "Work City")
         , (0x27, "Work State")
         ]

field_types = dict(fields) # Allow for indexing known fields by hex value
field_names = [x[1] for x in fields] # Allow for iteration over names

import sys, csv, tarfile
from os import path
from struct import unpack
from collections import defaultdict

def read_bb_field (fh):
    """
    Reads a standard field in a BlackBerry Address Book contact file. The
    format (to the best of my knowledge) is laid out above.

    Returns a tuple of (field_name, field_value), with field_name being a
    string if it is a known field type and an integer value otherwise.

    If the initial 2-byte read is not actually 2 bytes, it returns
    (False, <read value>)
    """
    # Read the first two bytes to determine the length of the entire field
    length_bytes = fh.read(2)
    if len(length_bytes) < 2:
        return False, length_bytes
    length = unpack("<H", length_bytes)[0]
    # Read the 1-byte field type
    field_type = unpack("<B", fh.read(1))[0]
    # Read the field itself, assumed to be length bytes as indicated above
    field = fh.read(length)
    try:
        field_type = field_types[field_type]
        # all known fields are NULL-terminated strings. Strip the NULL
        # character
        field = field[:-1]
    except KeyError:
        # Log unknown field types. Note that we can improve this a lot by:
        #   1. Adding known irrelevant field types that aren't logged
        #   2. Generating a better string representation of the field than
        #      simply dumping the binary value in there as a string.
        print >>sys.stderr, ('Unknown field type: %x, value: "%s"'
                             % (field_type, field))
    return field_type, field

def iterate_contacts (tarball):
    """
    Take an open tarfile object and yield open contact files from the Address
    Book. The contact files will be closed when iteration is resumed.
    """
    for member in tarball:
        if path.split(member.name)[0] == "Address Book":
            contact = tarball.extractfile(member)
            yield contact
            contact.close()

try:
    tarball = tarfile.open(sys.argv[1])
except IndexError:
    print >>sys.stderr, usage
    exit(2)

contacts = []
for contactfile in iterate_contacts(tarball):
    # We'll store each field from the contact file in a contact object
    contact = defaultdict(list)
    while True:
        field_type, field = read_bb_field(contactfile)
        if field_type is False: # end of input
            # assert field == "\0", "Non-NULL closing byte"
            break
        contact[field_type].append(field)
    contacts.append(contact)

# We're done with the tarball; free up some memory
tarball.close()

# Get CSV output object and write header row
csvout = csv.writer(sys.stdout)
csvout.writerow(field_names)

# Iterate over the contacts in order by name
for contact in sorted(contacts, key=lambda x: x[name]):
    # Write out the contact info for known fields to the CSV
    csvout.writerow(map(lambda x: " ".join(contact[x]),
                        field_names))
